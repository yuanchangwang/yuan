# ### 递归函数 : 自己调用自己的函数
"""
递:去
归:回

有去有回是递归
触底反弹引起递归回的过程
1.函数全部执行完毕
2.遇到return 的时候 
这两种都是回到上一次函数调用的位置.

每调用一次函数就会在内存里开辟一个栈帧空间,
每次调用结束后,要释放栈帧空间
递归实际上从内存角度上讲,就是开辟和释放栈帧空间的过程
在没有释放栈帧空间之前,相对应的这一层的变量值都会暂时保存.

"""

# 最简单的递归
def digui(n):
	print(n)
	if n>0:
		digui(n-1)
	print(n)
	
digui(5)

"""
代码解析:


# 递归去的过程
n = 5 print(5)  if 5>0 digui(5-1) => digui(4) 走到第13行 自己调用自己 后面的代码没走完,这一层暂停,暂定在13行,调用下一层
n = 4 print(4)  if 4>0 digui(4-1) => digui(3) 走到第13行 自己调用自己 后面的代码没走完,这一层暂停,暂定在13行,调用下一层
n = 3 print(3)  if 3>0 digui(3-1) => digui(2) 走到第13行 自己调用自己 后面的代码没走完,这一层暂停,暂定在13行,调用下一层
n = 2 print(2)  if 2>0 digui(2-1) => digui(1) 走到第13行 自己调用自己 后面的代码没走完,这一层暂停,暂定在13行,调用下一层
n = 1 print(1)  if 1>0 digui(1-1) => digui(0) 走到第13行 自己调用自己 后面的代码没走完,这一层暂停,暂定在13行,调用下一层
n = 0 print(0)  if 0>0? 条件不满足 跳过,执行print(0)  这个时候在这一层 0 打印了2次

# 递归回的过程
如果函数走到最后一层,走完了,就是触发回的过程 , 相当于触底反弹,要把先前没有执行完毕的代码 依次的执行完
回到n=1的情况,当时的第13行,继续向下执行
n = 1 print(1) 回来, 从第13行 继续向下执行 print(1)
回到n=2的情况,当时的第13行,继续向下执行
n = 2 print(2) 回来, 从第13行 继续向下执行 print(2)
回到n=3的情况,当时的第13行,继续向下执行
n = 3 print(3) 回来, 从第13行 继续向下执行 print(3)
回到n=4的情况,当时的第13行,继续向下执行
n = 4 print(4) 回来, 从第13行 继续向下执行 print(4)
回到n=5的情况,当时的第13行,继续向下执行
n = 5 print(5) 回来, 从第13行 继续向下执行 print(5)

到5这一层 递归函数彻底执行完毕,函数终止.
"""











